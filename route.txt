这个txt文档是用来详细记录每一次commit中做的修改内容, 以及各branch分支所做的内容不同之处

commit ID: 66cd08b2e8eefb463c7336960768282774d00842
《C++ 新经典——Linux C++通信架构实战》4.1 设计nginx初步的开发目录结构, 并学习makefile编写, 并阅读样例代码
代码从读取配置文件开始, 使用单例模式创建获取配置文件的类, 并自定义配置文件读取函数及字符串处理函数
C++单例模式比较有意思, 我们来总结一下
1. C++11之后可以使用局部静态变量创建单例
2. C++11之后可以使用call_once函数
3. 模板化局部静态变量构造单例

commit ID: 6b35f55a05373a0cbe3b0e6612e3c9a96e1a18e5
使用加锁的Lazy Load方式书写单例模式, 因为读取配置文件发生在主程序启动的开始, 所以实际并不存在多线程竞争的情况, 仅为学习书写POSIX标准下的加锁方式 

commit ID: 6b35f55a05373a0cbe3b0e6612e3c9a96e1a18e5
创建了3个分支但并不合并, 分支cpp11_call_once测试使用call_once函数书写单例模式, cpp11_static分支测试使用类局部静态变量的方式书写单例模式, 因为cpp11提供的2中新模式会自动管理内存或者使用&引用方式创建并返回单例实例, 因此不涉及内存管理问题, 无需考虑单例实例的内存释放

commit ID: ac9ef6986034a26f619f8b501d9c8c685a1c75c5
自定义加载配置信息文件的方式, 对于文件流的处理简单直接, 但应当学习、明白配置文件在大型工程项目中的作用, 同时了解CCF配置文件格式
项目投入实际应用, 应当采用Json、XML等标准格式并结合优秀的相关C语言库进行配置文件的读取、写入

commit ID: 7644b171365768833d9f3357eeea487260d86132
按照书籍代码提供的Makefile代码进行书写

commit ID: adb41af5a35aad51ddd3509492251f3588e9be26
重新书写李云的《驾驭Makefile》，之后可能会对Makefile代码进行修订，不再单独在git中展示修订差异，可以学习cmake、xmake代替使用make+makefile的编译控制模式

commit ID: bad9276e449b7119e5c19bb89d7a352fe10ca5eb
C++单例模式创建单例的指针、引用, 但是C++创建单例模式使用的是静态函数, 因此不能通过析构函数进行内存自动释放, 因此需要使用内部类的析构函数进行内存释放
C++不同的单例模式有不同的内存管理模式:
1. 本项目中使用的双重加锁创建单例模式的方法, 需要使用内部类的析构函数进行内存释放
2. C++11提供的局部静态变量创建单例模式, 无需使用内部类的析构函数进行内存释放
3. C++11提供的call_once函数创建单例模式, 无需使用内部类的析构函数进行内存释放

commit ID: 2f706bf1a650ad962bee4e28acdd5f8b15911af3
补充自定义的string字符处理函数
补充makefile文件内容, 可以使用make编译项目, 并运行nginx
本项目有2个缺陷:
1. makefile组织简陋, 采用李云老师的makefile模板文件是更佳的选择; 最佳选择是使用cmake配合CMakeLists自动生成的makefile文件组织代码结构
2. glibc是linux系统的标准C语言库, string.h仅定义少量字符处理函数, 且采用内存管理技术, 程序运行速度快但书写复杂, 可远观其妙而不可亵玩其精髓

commit ID: e861781e8b0b8e6e2ebdf02fe164535ef3e48dd8
自定义日志处理相关的函数、字符串打印输出函数
日志相关的处理是极为重要的编程准备工作, 本项目若不采用C++的异常处理, 而使用C语言的信号处理机制, 则后续几乎所有的函数都在处理时需要考虑错误中断而要将相关的错误通过日志处理保存到日志文件中
日志处理中主要要以下数个关键点:
1. 自定义字符串输出函数, 采用与标准print函数相同的%标识符, 并自定义项目特殊的标志
2. 自定义字符串拼接逻辑, 确定自定义的日志信息字符串构成方式
3. linux操作系统的进程组机制, 保证了write作为原子操作, 不同进程同时写日志文件, 不会出现混乱, 否则应该采用缓存同步配合锁机制的方式保证多进程、多线程同时写文件正常写入
4. 日志根据需要需要分等级处理

commit ID: d6501b6b845c02202cef36fba8cbb7b99430c2c3
处理与信号机制、创建守护进程相关的代码
信号处理主要有以下3点注意事项:
1. 需要使用sigaction函数对信号进行屏蔽、解除屏蔽的处理
2. 信号可以作为C语言编程中信息触发的手段, 因此可以自定义信号处理函数, 对于信号的处理应当尽可能简单、快速
3. 注意对于子进程的信号处理, 父进程如不使用wait()、waitpid()函数对SIGCHLD信号进行处理, 子进程会成为僵尸进程
守护进程主要有以下2点注意事项:
1. 守护进程会重定向标准输入、输出, 会影响其他代码正常显示信息
2. 守护进程需要脱离终端运行